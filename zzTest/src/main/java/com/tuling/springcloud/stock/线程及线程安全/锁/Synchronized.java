package com.tuling.springcloud.stock.线程及线程安全.锁;

public class Synchronized {
    /**
     * synchronized
     * 可见性：被多线程使用的对象都直接读取主内存，修改完也立刻刷新到主内存
     * 有序性：指令重排对单线程没有影响，可以保证有序性
     * 原子性：保证synchronized代码块会在代码固定的位置被执行，但是不保证代码块前后及内部的代码顺序性
     *
     * synchronized的实现原理：
     * 1、修饰方法时，会被字节码上添加acc_synchronized表示，这表示线程进入方法需要先获取这个对象的monitor的所有权
     * 在方法结束后，会释放monitor的所有权。在方法执行期间，其他线程都无法获取monitor的所有权，保证代码块的原子性
     * 2、修饰代码块时：字节码会添加monitorEnter和monitorExit指令，在进入代码块时，该线程获取加锁对象monitor的所有权
     * 此时其他线程想要获取该对象的monitor的所有权会被阻塞。
     * synchronized持有对象的monitor会存在一个计数器，这个计数器会在线程进入时+1，出去时-1，这可以用来实现synchronized的可重入锁特性
     *
     *  在jdk1.5之后加入了，锁升级的过程，synchronized性能不在差劲
     *  锁升级将锁分为4个阶段  1、偏向锁  2、轻量级锁 3、自旋锁  4、重量级锁
     *  1、偏向锁：当一个锁不存在竞争的时候，锁被重入的时候，会校验对象头的线程ID，如果一致就省去加锁过程，直接重入，并在重入次数上+1，
     *  偏向锁只能被一个线程持有，当另外一个线程竞争这个对象并加锁时，这个线程继续去获取锁，就会匹配线程ID失败，此时取消偏向锁升级为轻量级锁
     *  2、轻量级锁：当线程交替获取锁，并且没发生锁竞争的时候，synchronized表现出轻量级锁，各个线程交替获取锁，放弃锁，其他线程恰好也不阻塞
     *  3、自旋锁：当发生锁竞争时，那个被阻塞线程会进入自选状态，消耗一定的CPU资源，但不会挂起，免去线程唤醒及切换的时间，提升性能
     *  4、重量级锁：当synchronized代码块性能一般，超出了自旋锁的自选次数，锁升级为重量级锁，重量级锁就跟JDK1.5之前的一样了，性能一般
     *
     *
     *  锁消除：当一个synch代码块被写在一个完全不可能出现并发的位置时，synch的功能会被消除
     */
}
